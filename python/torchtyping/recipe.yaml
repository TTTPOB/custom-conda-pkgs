context:
  version: 0.1.5

package:
  name: torchtyping
  version: ${{ version }}

source:
- url: https://pypi.org/packages/source/t/torchtyping/torchtyping-${{ version }}.tar.gz
  sha256: fb51e1792536223e2497b1e106ed0cbe681f7324044599cb718d03be3f2b3851

build:
  script: ${{ PYTHON }} -m pip install .
  noarch: python

requirements:
  host:
  - python >=3.7.0
  - pip
  - setuptools
  run:
  - python >=3.7.0
  - pytorch >=1.7.0
  - typeguard <3,>=2.11.1

tests:
- python:
    imports:
    - torchtyping
    pip_check: true

about:
  homepage: https://github.com/patrick-kidger/torchtyping
  summary: Runtime type annotations for the shape, dtype etc. of PyTorch Tensors.
  description: "<h1 align='center'>torchtyping</h1>\n<h2 align='center'>Type annotations for a tensor's shape, dtype, names, ...</h2>\n\n*Welcome! For new projects I now **strongly** recommend using my newer [jaxtyping](https://github.com/google/jaxtyping) project instead. It supports PyTorch, doesn't actually depend on JAX, and unlike TorchTyping it is compatible with static type checkers. :)*\n\n---\n\nTurn this:\n```python\ndef batch_outer_product(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:\n    # x has shape (batch, x_channels)\n    # y has shape (batch, y_channels)\n    # return has shape (batch, x_channels, y_channels)\n\n    return x.unsqueeze(-1) * y.unsqueeze(-2)\n```\ninto this:\n```python\ndef batch_outer_product(x:   TensorType[\"batch\", \"x_channels\"],\n                        y:   TensorType[\"batch\", \"y_channels\"]\n                        ) -> TensorType[\"batch\", \"x_channels\", \"y_channels\"]:\n\n    return x.unsqueeze(-1) * y.unsqueeze(-2)\n```\n**with programmatic checking that the shape (dtype, ...) specification is met.**\n\nBye-bye bugs! Say hello to enforced, clear documentation of your code.\n\nIf (like me) you find yourself littering your code with comments like `# x has shape (batch, hidden_state)` or statements like `assert x.shape == y.shape` , just to keep track of what shape everything is, **then this is for you.**\n\n---\n\n## Installation\n\n```bash\npip install torchtyping\n```\n\nRequires Python >=3.7 and PyTorch >=1.7.0.\n\nIf using [`typeguard`](https://github.com/agronholm/typeguard) then it must be a version <3.0.0.\n\n## Usage\n\n`torchtyping` allows for type annotating:\n\n- **shape**: size, number of dimensions;\n- **dtype** (float, integer, etc.);\n- **layout** (dense, sparse);\n- **names** of dimensions as per [named tensors](https://pytorch.org/docs/stable/named_tensor.html);\n- **arbitrary number of batch dimensions** with `...`;\n- **...plus anything else you like**, as `torchtyping` is highly extensible.\n\nIf [`typeguard`](https://github.com/agronholm/typeguard) is (optionally) installed then **at runtime the types can be checked** to ensure that the tensors really are of the advertised shape, dtype, etc. \n\n```python\n# EXAMPLE\n\nfrom torch import rand\nfrom torchtyping import TensorType, patch_typeguard\nfrom typeguard import typechecked\n\npatch_typeguard()  # use before @typechecked\n\n@typechecked\ndef func(x: TensorType[\"batch\"],\n         y: TensorType[\"batch\"]) -> TensorType[\"batch\"]:\n    return x + y\n\nfunc(rand(3), rand(3))  # works\nfunc(rand(3), rand(1))\n# TypeError: Dimension 'batch' of inconsistent size. Got both 1 and 3.\n```\n\n`typeguard` also has an import hook that can be used to automatically test an entire module, without needing to manually add `@typeguard.typechecked` decorators.\n\nIf you're not using `typeguard` then `torchtyping.patch_typeguard()` can be omitted altogether, and `torchtyping` just used for documentation purposes. If you're not already using `typeguard` for your regular Python programming, then strongly consider using it. It's a great way to squash bugs. Both `typeguard` and `torchtyping` also integrate with `pytest`, so if you're concerned about any performance penalty then they can be enabled during tests only.\n\n## API\n\n```python\ntorchtyping.TensorType[shape, dtype, layout, details]\n```\n\nThe core of the library.\n\nEach of `shape`, `dtype`, `layout`, `details` are optional.\n\n- The `shape` argument can be any of:\n  - An `int`: the dimension must be of exactly this size. If it is `-1` then any size is allowed.\n  - A `str`: the size of the dimension passed at runtime will be bound to this name, and all tensors checked that the sizes are consistent.\n  - A `...`: An arbitrary number of dimensions of any sizes.\n  - A `str: int` pair (technically it's a slice), combining both `str` and `int` behaviour. (Just a `str` on its own is equivalent to `str: -1`.)\n  - A `str: str` pair, in which case the size of the dimension passed at runtime will be bound to _both_ names, and all dimensions with either name must have the same size. (Some people like to use this as a way to associate multiple names with a dimension, for extra documentation purposes.)\n  - A `str: ...` pair, in which case the multiple dimensions corresponding to `...` will be bound to the name specified by `str`, and again checked for consistency between arguments.\n  - `None`, which when used in conjunction with `is_named` below, indicates a dimension that must _not_ have a name in the sense of [named tensors](https://pytorch.org/docs/stable/named_tensor.html).\n  - A `None: int` pair, combining both `None` and `int` behaviour. (Just a `None` on its own is equivalent to `None: -1`.)\n  - A `None: str` pair, combining both `None` and `str` behaviour. (That is, it must not have a named dimension, but must be of a size consistent with other uses of the string.)\n  - A `typing.Any`: Any size is allowed for this dimension (equivalent to `-1`).\n  - Any tuple of the above. For example.`TensorType[\"batch\": ..., \"length\": 10, \"channels\", -1]`. If you just want to specify the number of dimensions then use for example `TensorType[-1, -1, -1]` for a three-dimensional tensor.\n- The `dtype` argument can be any of:\n  - `torch.float32`, `torch.float64` etc.\n  - `int`, `bool`, `float`, which are converted to their corresponding PyTorch types. `float` is specifically interpreted as `torch.get_default_dtype()`, which is usually `float32`.\n- The `layout` argument can be either `torch.strided` or `torch.sparse_coo`, for dense and sparse tensors respectively.\n- The `details` argument offers a way to pass an arbitrary number of additional flags that customise and extend `torchtyping`. Two flags are built-in by default. `torchtyping.is_named` causes the [names of tensor dimensions](https://pytorch.org/docs/stable/named_tensor.html) to be checked, and `torchtyping.is_float` can be used to check that arbitrary floating point types are passed in. (Rather than just a specific one as with e.g. `TensorType[torch.float32]`.) For discussion on how to customise `torchtyping` with your own `details`, see the [further documentation](https://github.com/patrick-kidger/torchtyping/blob/master/FURTHER-DOCUMENTATION.md#custom-extensions).\n- Check multiple things at once by just putting them all together inside a single `[]`. For example `TensorType[\"batch\": ..., \"length\", \"channels\", float, is_named]`.\n\n```python\ntorchtyping.patch_typeguard()\n```\n\n`torchtyping` integrates with `typeguard` to perform runtime type checking. `torchtyping.patch_typeguard()` should be called at the global level, and will patch `typeguard` to check `TensorType`s.\n\nThis function is safe to run multiple times. (It does nothing after the first run). \n\n- If using `@typeguard.typechecked`, then `torchtyping.patch_typeguard()` should be called any time before using `@typeguard.typechecked`. For example you could call it at the start of each file using `torchtyping`.\n- If using `typeguard.importhook.install_import_hook`, then `torchtyping.patch_typeguard()` should be called any time before defining the functions you want checked. For example you could call `torchtyping.patch_typeguard()` just once, at the same time as the `typeguard` import hook. (The order of the hook and the patch doesn't matter.)\n- If you're not using `typeguard` then `torchtyping.patch_typeguard()` can be omitted altogether, and `torchtyping` just used for documentation purposes.\n\n```bash\npytest --torchtyping-patch-typeguard\n```\n\n`torchtyping` offers a `pytest` plugin to automatically run `torchtyping.patch_typeguard()` before your tests. `pytest` will automatically discover the plugin, you just need to pass the `--torchtyping-patch-typeguard` flag to enable it. Packages can then be passed to `typeguard` as normal, either by using `@typeguard.typechecked`, `typeguard`'s import hook, or the `pytest` flag `--typeguard-packages=\"your_package_here\"`.\n\n## Further documentation\n\nSee the [further documentation](https://github.com/patrick-kidger/torchtyping/blob/master/FURTHER-DOCUMENTATION.md) for:\n\n- FAQ;\n  - Including `flake8` and `mypy` compatibility;\n- How to write custom extensions to `torchtyping`;\n- Resources and links to other libraries and materials on this topic;\n- More examples.\n"
  license: Apache-2.0
